from utils import *from mantidsimple import *import MantidFramework MantidFramework.mtd.initialise()from mantidplot import *from DirectEnergyConversion import *import time as timeimport dgreduceimport inspectimport numpyimport PySliceimport PyChop##################################################global mpl, wdir, instname,ext,instdae,mon1_spec,mon2_spec,mon3_specmpl = 0if mpl==1:	print 'Using matplotlib graphics'if mpl==0:	print 'Using qtiplot graphics'wdir=""instname=""ext=""instdae=""plotmkr=""plotcolor="red"#change path to the directory where qtigenie residesprint 'Working directory set to ',str(os.path.dirname(inspect.getmodule(dgreduce).__file__))cd(str(os.path.dirname(inspect.getmodule(dgreduce).__file__)))#set up some 'isis friendly' alias names to dgreduceiliad_setup=dgreduce.setupiliad=dgreduce.arb_unitsiliad_abs=dgreduce.abs_unitsiliad_help=dgreduce.help##############################################class Data_1D():        def __init__(Data_1D):                Data_1D.xdata=[]                Data_1D.ydata=[]                Data_1D.edata=[]        def plot(wksp):                plot(wksp.xdata,wksp.ydata,color=plotcolor)	def plotwe(wksp):                errorbar(wksp.xdata,wksp.ydata,wksp.edata,color=plotcolor)                        def Add_1d(wksp,factor):                wkspout=Data_1D()                wkspout.ydata=numpy.zeros(wksp.ydata.shape)                wkspout.edata=wksp.edata                factor=numpy.ones(wksp.ydata.shape)*factor                np.add(wksp.ydata,factor,wkspout.ydata)                wkspout.xdata=wksp.xdata                wkspout.edata=wksp.edata                return wkspout                       def Minus_1D(wksp,factor):                wkspout=Data_1D()                wkspout.ydata=numpy.zeros(wksp.ydata.shape)                wkspout.edata=wksp.edata                factor=numpy.ones(wksp.ydata.shape)*factor                np.subtract(wksp.ydata,factor,wkspout.ydata)                wkspout.xdata=wksp.xdata                wkspout.edata=wksp.edata                return wkspout        def Multiply_1d(wksp,factor):                wkspout=Data_1D()                wkspout.ydata=numpy.zeros(wksp.ydata.shape)                wkspout.edata=numpy.zeros(wksp.ydata.shape)                factor=numpy.ones(wksp.ydata.shape)*factor                np.multiply(wksp.ydata,factor,wkspout.ydata)                np.multiply(wksp.edata,factor,wkspout.edata)                wkspout.xdata=wksp.xdata                return wkspout        def Divide_1d(wksp,factor):                wkspout=Data_1D()                wkspout.ydata=numpy.zeros(wksp.ydata.shape)                wkspout.edata=numpy.zeros(wksp.ydata.shape)                factor=numpy.ones(wksp.ydata.shape)*factor                np.divide(wksp.ydata,factor,wkspout.ydata)                np.divide(wksp.edata,factor,wkspout.edata)                wkspout.xdata=wksp.xdata                return wkspout        def integrate(wksp,t1,t2):                out=wksp.xscale(t1,t2)                integral=np.trapz(out.ydata,out.xdata)                print "Integrated area= ", integral                return integral        def xscale(dat,t1,t2):        #trim a 1d workspace to within the limits                int1=Data_1D()                aa=(dat.xdata >=t1) & (dat.xdata <=t2)                int1.xdata=np.extract(aa, dat.xdata)                int1.ydata=np.extract(aa, dat.ydata)                int1.edata=np.extract(aa, dat.edata)                return int1class Data_2D():		        def __init__(Data_2D):                Data_2D.zdata=[]                Data_2D.xdata=[]                Data_2D.ydata=[]                Data_2D.edata=[]        def sumspec(wksp,*args):                wkspout=Data_1D()                wkspout.ydata=np.sum(wksp.zdata,1)                wkspout.xdata=wksp.ydata		if len(args)==2:			wkspout.ydata=np.sum(wksp.zdata[args[0]-1:args[1]-1][:],1)			wkspout.xdata=wksp.ydata[args[0]-1:args[1]-1]                return wkspout        def sum2d(wsk,s1,s2):                wkspout=Data_1D()                aa=(np.transpose(wsk.zdata[s1:s2]))                wkspout.ydata=aa.sum(1)                wkspout.xdata=wsk.xdata[0]                edata=(np.transpose(wsk.edata[s1:s2]))**2                wkspout.edata=sqrt(edata.sum(1))                return wkspoutdef createqtiTable(*args):#create a qti table of length arg1 with name arg0	if len(args)==0:		out=qti.app.newTable()	if len(args)==2:		out=qti.app.newTable(args[0],args[1],3)		out.setColumnRole(3, 5)	return out 					def fillqtiTable(data):	return	#def arb_units(wb_run,sample_run,ei_guess,rebin,mapfile):def test(wb_run,sample_run,ei_guess,rebin,mapfile,**kwargs):	print wb_run,sample_run,ei_guess,rebin,mapfile,kwargs	for key in kwargs:		print "another keyword arg: %s: %s" % (key, kwargs[key])			if kwargs.has_key('fixei'):		fix_ei = kwargs.get('fixei')		print fix_ei				normalise_method = 'monitor-1'	background = False	fix_ei = False	save_formats = ['.spe']	#Set parameters for the run		energy_bins = rebin	background_range=[15000,19000]	wb_integr_range=[20,100]	diag_median_rate_limit_hi=3.0	diag_median_rate_limit_lo=0.1	bkgd_median_rate_limit=5.0def trim(dat,t1,t2):        #trim a 1d workspace to within the limits        int1=Data_1D()        aa=(dat.xdata >=t1) & (dat.xdata <=t2)        int1.xdata=np.extract(aa, dat.xdata)        int1.ydata=np.extract(aa, dat.ydata)        int1.edata=np.extract(aa, dat.edata)        return int1def listfiles():	"""	list function for the working data directory	"""	aa= os.listdir(wdir)	for i in range(0,len(aa)):		print aa[i]def print_locals():	a=locals()	for i in range(0,len(a)):		print a[i]def print_globals():	a=locals()	for i in range(0,len(a)):		print a[i]##instrument definitionsdef setinst(iname):	"""	setinst('mar')	setup instrument defaults by reading the instname.txt file	"""	if iname =='mer' or iname=='MER':		print "Reading params file for merlin from current working directory"		readsetuptxtfile('merlin.txt')	if iname =='map' or iname=='MAP':		print "Reading params file for maps from current working directory"		readsetuptxtfile('maps.txt')	if iname =='let' or iname=='LET':		print "Reading params file for LET from current working directory"		readsetuptxtfile('let.txt')	if iname =='mar' or iname=='MAR':		print "Reading params file for MARI from current working directory"		readsetuptxtfile('mari.txt')def readsetuptxtfile(fname):		global wdir, instname,ext,instdae,mon1_spec,mon2_spec,mon3_spec		f = open(fname, 'r+')		instring=f.readline()		wdir= instring.split()[1]			instring=f.readline()		instname=instring.split()[1]			instring=f.readline()		ext=instring.split()[1]			instring=f.readline()		instdae=instring.split()[1]			instring=f.readline()		mon1_spec=int(instring.split()[1])			instring=f.readline()		mon2_spec=int(instring.split()[1])			instring=f.readline()		mon3_spec=int(instring.split()[1])		f.close()		return wdir,instname,ext,instdae,mon1_spec,mon2_spec,mon3_specdef setmon_1_spec(spec):	"""	sets the default mon 1 spec to another spectrum	"""	global mon1_spec	mon1_spec=spec	print 'Monitor one spectrum changed to ',mon1_spec	return mon1_specdef showgpath():	"""	shows the gloabal qtigenie variables	"""	print '----------------------------------------------------------'	print 'Global ', instname, ' specific variables are:'		print 'Data directory', wdir 		print 'file extension', ext	print 'dae path ', instdae	print 'Monitor 1 spectrum' ,mon1_spec	print 'Monitor 2 spectrum' ,mon2_spec	print 'Monitor 3 spectrum' ,mon3_specdef head(runnumber):	"""	classic head command	"""	runnumber=getnumor(runnumber)	fullname=getfilename(runnumber)	runinfo=RawFileInfo(fullname,GetRunParameters=True)	title=runinfo.getPropertyValue('runtitle')	print ('Title              :'), title	temp = mtd.getTableWorkspace('Raw_RPB')	print ('uamps              :'), temp.getDouble('r_gd_prtn_chrg', 0)	print ('Run duration (hrs) :'), temp.getInt('r_dur', 0) /3600		#R_dur # r_durunits# r_dur_freq# r_dmp# r_dmp_units# r_dmp_freq#r_freq		#r_gd_prtn_chrg# r_tot_prtn_chrg# r_goodfrm#r_rawfrm# r_dur_wanted#r_dur_secs		#r_mon_sum1# r_mon_sum2#r_mon_sum3# r_enddate#r_endtime#r_propdef iv(wksp_in):	"""	iv(wksp_in)	initiate the instrument view with workspace wksp_in	"""	#bring the mantid instrument view window up	#need to call with a string??	wksp=str(wksp_in)	iv=getInstrumentView(wksp)	iv.showWindow()def getfilename(runnumber):	"""	returns the file name and path and checks it exists on the filesystem	"""	if os.path.exists(wdir+instname+str(runnumber)+'.raw'):		fullname=wdir+instname+str(runnumber)+'.raw'		return fullname	elif os.path.exists(wdir+instname.lower()+str(runnumber)+'.raw'):		fullname=wdir+instname.lower()+str(runnumber)+'.raw'		return fullname	elif os.path.exists(wdir+instname.lower()+str(runnumber)+'.RAW'):		fullname=wdir+instname.lower()+str(runnumber)+'.RAW'		return fullname	elif os.path.exists(wdir+instname+str(runnumber)+'.RAW'):		fullname=wdir+instname+str(runnumber)+'.RAW'		return fullname	else:		fullname=wdir+instname+str(runnumber)+'.nsx'def load(*args):	"""	load raw or nxs files	eg:	w1=load(1234): will load the file instname1234.raw /nxs	"""  # get the lhs of the calling command	n,r=lhs('both')	wksp=r[0]	if (args[0])=='dae': #runnumber == 'dae':		print 'Access DAE', instdae		awksp=LoadDAE(instdae,OutputWorkspace=wksp)		return mtd[wksp]	else:			runnumber=getnumor(args[0])						if os.path.exists(wdir+instname+str(runnumber)+'.raw'):			fullname=wdir+instname+str(runnumber)+'.raw'			print fullname			awksp=Load(fullname,OutputWorkspace=wksp,Cache="Never")			ConvertToDistribution(wksp)			runinfo=RawFileInfo(fullname,GetRunParameters=True)			title=runinfo.getPropertyValue('runtitle')			return mtd[wksp]		elif os.path.exists(wdir+instname.lower()+str(runnumber)+'.raw'):			fullname=wdir+instname.lower()+str(runnumber)+'.raw'			print fullname			awksp=Load(fullname,OutputWorkspace=wksp,Cache="Never")			ConvertToDistribution(wksp)			runinfo=RawFileInfo(fullname,GetRunParameters=True)			title=runinfo.getPropertyValue('runtitle')			return mtd[wksp]		elif os.path.exists(wdir+instname.lower()+str(runnumber)+'.RAW'):			fullname=wdir+instname.lower()+str(runnumber)+'.RAW'			print fullname			awksp=Load(fullname,OutputWorkspace=wksp,Cache="Never")			ConvertToDistribution(wksp)			runinfo=RawFileInfo(fullname,GetRunParameters=True)			title=runinfo.getPropertyValue('runtitle')			return mtd[wksp]		elif os.path.exists(wdir+instname+str(runnumber)+'.RAW'):			fullname=wdir+instname+str(runnumber)+'.RAW'			print fullname			awksp=Load(fullname,OutputWorkspace=wksp,Cache="Never")			ConvertToDistribution(wksp)			runinfo=RawFileInfo(fullname,GetRunParameters=True)			title=runinfo.getPropertyValue('runtitle')			return mtd[wksp]		else:			fullname=wdir+instname+str(runnumber)+'.nsx'			print fullname			awksp=Load(fullname,OutputWorkspace=wksp,Cache="Never")			ConvertToDistribution(wksp)			runinfo=RawFileInfo(fullname,GetRunParameters=True)			title=runinfo.getPropertyValue('runtitle')			return mtd[wksp]			def load_monitors(*args):	"""	load monitors from a raw or nxs files	eg:	w1=load_monitors(1234): will load the monitors  file instname1234.raw /nxs	"""  # load monitors only	n,r=lhs('both')	wksp=r[0]	if len(args)==1: #runnumber == 'dae':		#print 'Access DAE', instdae		#mantid.LoadDAE(instdae,OutputWorkspace="data")		runnumber=getnumor(args[0])				fullname=wdir+instname+str(runnumber)+ext		print fullname		awksp=LoadRaw(fullname,OutputWorkspace=wksp,Cache="Never",LoadMonitors="Separate")		ConvertToDistribution(wksp+'_Monitors')		runinfo=RawFileInfo(fullname,GetRunParameters=True)		title=runinfo.getPropertyValue('runtitle')		clear(wksp)		return mtd[wksp+'_Monitors']	else:		print 'error'def getnumor(runnumber):	#creates a string runnumber from interger input and pads with zerso to cope with isis 	#file naminging convention need an additional switch for ts1 and ts2 instruments	#to cope with the different number of preceeding zeros.		if instname=='LET':		run=str(runnumber)			if len(run) == 3:			runnumber_out='00000'+run			return runnumber_out			if len(run) == 4:			runnumber_out='0000'+run			return runnumber_out		if len(run) == 5:			runnumber_out='000'+run			return runnumber_out		if len(run) == 6:			runnumber_out='00'+run			return runnumber_out		if len(run) == 7:			runnumber_out='0'+run			return runnumber_out		if len(run) == 8:			runnumber_out=run			return runnumber_out	else:		run=str(runnumber)			if len(run) == 3:			runnumber_out='00'+run			return runnumber_out			if len(run) == 4:			runnumber_out='0'+run			return runnumber_out		if len(run) == 5:			runnumber_out=run			return runnumber_out	def loadascii(name):	"""	loads the x,y,e file as ascii	w1=loadascii('myfile.txt')	"""	#load three col tab delim ascii from current path	n,r=lhs('both')	wksp=r[0]	fullname=os.getcwd()+'/'+name	print 'Loading ',fullname	LoadAscii(fullname,OutputWorkspace=wksp,Separator="Tab",Unit="Empty")	return mtd[wksp]def ass(wksp):	"""	assign a workspace or a raw file as current data for plotting	ass(w1)	ass(1234)	"""	#define a workspace as current_working_data within the shell	#simplifies plot etc	global current_working_data	if mtd.workspaceExists(str(wksp)):		current_working_data=wksp	else:		tmp=load(wksp)		current_working_data=tmp	return current_working_datadef clear(wksp):	"""	clear workspace 	clear(w1)	"""	name=wksp.getName()	mtd.deleteWorkspace(name)def whos():	"""	list all current loaded workspaces	"""	names=mtd.getWorkspaceNames()	print 'Instrument name: ', instname, '\t', 'Data Directory: ',wdir	print '---------------------------------------------------------------------------'	print 'WkSp Name', '\t', '\t', '\t', 'Allocated Mem', '\t', 'Title', '\t'	print '---------------------------------------------------------------------------'	for i in range(0,len(names)):		name = names[i]		tmp=mtd[name]		mem=tmp.getMemorySize()/1024		title=tmp.getTitle()		print name,'\t','\t','\t',mem,'Mb','\t',titledef sync():	names=mtd.getWorkspaceNames()	for i in range(0,len(names)):		name = names[i]		print name		#name = mtd[name]		evalstr='global '+str(name)		exec(evalstr)		evalstr1=name+'=mtd['+"'"+str(name)+"'"+']'		exec(evalstr1)	return name	def default_plotting(inp):	global mpl		print 'set default graphics to matplotlib (1) or qtiplot(0)'	mpl=inpdef dspacing(wksp_in):	"""	convert workspace to dpsacing	w2=dspacing(w1)	"""	#convert input to d spacing and return	n,r=lhs('both')	wksp_out=r[0]	ConvertUnits(InputWorkspace=wksp_in,OutputWorkspace=wksp_out,Target="dSpacing")	return mtd[wksp_out]def get_ei(wksp_in,guess):	"""	runs getei on a workpsace ei result will be stored in that workspace	"""	global mon2_peak	out=GetEi(wksp_in,mon2_spec,mon3_spec,guess)	mon2_peak = float(out.getPropertyValue("FirstMonitorPeak"))	mon2_index = int(out.getPropertyValue("FirstMonitorIndex"))	ei = (wksp_in.getSampleDetails().getLogData("Ei").value)	print 'Incident Energy = ', ei, 'meV'	print 'Peak in monitor',mon2_index, 'at ', mon2_peak ,'usec'	return ei,mon2_peakdef diag(wb_wksp,run_wksp):	"""	runs diag on a white beam and a sample run to list bad spectra	"""	#performs the diag test on a WB van and sample run	#and returns a list of masked detectors		#white beam integrates from 1000-2000 musec	wb_out=MedianDetectorTest(InputWorkspace=wb_wksp,OutputWorkspace='wb_tmp',StartWorkspaceIndex="1000",EndWorkspaceIndex="2000")	WB_SpectraList=wb_out.getPropertyValue('BadSpectraNums')		#monorun has threshold set higher and integrate all tof	run_out=MedianDetectorTest(InputWorkspace=run_wksp,OutputWorkspace='run_tmp',HighThreshold="10")	Run_SpectraList=run_out.getPropertyValue('BadSpectraNums')			bad_dets=maskUnion(Run_SpectraList,WB_SpectraList)	print 'number of masked spectra = ', len(bad_dets)	return bad_detsdef maskUnion(a,b):	a=eval(a)	b=eval(b)	aa=list(a)	bb+list(b)	return list(set.union(set(aa),set(bb)))def SaveData(out,run_num):	"""	save workspace as spe format	SaveData(w1,'fname')	"""	runnumber=getnumor(run_num)	fullname=wdir+instname+str(runnumber)+'.spe'	SaveSPE(out,fullname)def normalise(*args):	"""	normalise 	w2=normalise(w1,1) <-- normalise to monitor default integration limits of 1000 2000 usec	w2=normalise(w1,2) <-- normalise to uamp	w2=normalise(w1,1,1000,2000) <-- normalise to monitor with sepcifies integration limits	"""		n,r=lhs('both')	wksp_out=r[0]	if len(args)==2: #must have two imputs at least input wksp and method		wksp_in =  args[0]		method  =  args[1]		if method == 1:			print 'Normalise to monitor 1'			#use defaults for the rest			mon_spec=mon1_spec			time_min=1000			time_max=2000							if wksp_in.isDistribution():				print 'input wksp is distribution'								ConvertFromDistribution(wksp_in)				NormaliseToMonitor(InputWorkspace=wksp_in,OutputWorkspace=wksp_out,MonitorSpectrum=mon_spec,IntegrationRangeMin=time_min,IntegrationRangeMax=time_max,IncludePartialBins="1")				#put all data back to distriubution								ConvertToDistribution(wksp_out)				ConvertToDistribution(wksp_in)			else:				NormaliseToMonitor(InputWorkspace=wksp_in,OutputWorkspace=wksp_out,MonitorSpectrum=mon_spec,IntegrationRangeMin=time_min,IntegrationRangeMax=time_max,IncludePartialBins="1")		if method ==2:			print 'Normalise to current'			NormaliseByCurrent(wksp_in,wksp_out)			if len(args)==4: #must have two imputs at least input wksp and method		wksp_in = args[0]		method  =  args[1]		#assume normalise to monitor		if method == 1:			print 'Normalise to monitor ', args[1],'is spec ',mon1_spec,'between ',args[2],' and ',args[3],' usec'			#use inputs for the rest			mon_spec=mon1_spec			time_min=str(args[2])			time_max=str(args[3])			if wksp_in.isDistribution():				print 'input wksp is distribution'								ConvertFromDistribution(wksp_in)				NormaliseToMonitor(InputWorkspace=wksp_in,OutputWorkspace=wksp_out,MonitorSpectrum=mon_spec,IntegrationRangeMin=time_min,IntegrationRangeMax=time_max,IncludePartialBins="1")				#put all data back to distriubution								ConvertToDistribution(wksp_out)				ConvertToDistribution(wksp_in)			else:				NormaliseToMonitor(InputWorkspace=wksp_in,OutputWorkspace=wksp_out,MonitorSpectrum=mon_spec,IntegrationRangeMin=time_min,IntegrationRangeMax=time_max,IncludePartialBins="1")					return mtd[wksp_out]	def rebin(wksp_in,params):	"""	rebin wksp with limits set by input string	rebin(w1,0,100,1000) rebin w1 from 0 to 1000 in step of 100	"""	n,r=lhs('both')	wksp_out=r[0]	Rebin(wksp_in,wksp_out,params)	return mtd[wksp_out]def integrate_over_runs(runstart,runstop,tmin,tmax,specmin,specmax,*args,**kwargs):	"""	reads in multiple runs and calculates integral of a region of interest	as there is no simple method to create a mantid workspace the output is 	cast as a data_1d object	integrate_over_runs(runstart,runstop,tmin,tmax,specmin,specmax)	or	integrate_over_runs(runstart,runstop,tmin,tmax,specmin,specmax,xaxis_start_pos,xstep)	integrate_over_runs(runstart,runstop,tmin,tmax,specmin,specmax,xaxis_start_pos,xstep,normalise=mon)	integrate_over_runs(runstart,runstop,tmin,tmax,specmin,specmax,xaxis_start_pos,xstep,normalise=mon,mon_range=[1000,2000])	integrate_over_runs(runstart,runstop,tmin,tmax,specmin,specmax,xaxis_start_pos,xstep,normalise=uamp)	"""	if kwargs.has_key('normalise'):		norm_method = kwargs.get('normalise')		if norm_method=='uamp':			print 'Normalise to uamps'			norm=2		elif norm_method=='mon':			print 'Normalise to monitor 1'			norm=1		else:		print 'default uamphr normalisation use keyword normalise to change'		norm =2	if kwargs.has_key('normalise') and kwargs.get('normalise')=='mon' and kwargs.has_key('mon_range'):		mon_int_range=kwargs.get('mon_range')	jj=1	outdat=createqtiTable('integral',runstop+1-runstart)		for i in range(runstart,runstop+1):				tmp=load(i)		if kwargs.has_key('normalise') and kwargs.get('normalise')=='mon' and kwargs.has_key('mon_range'):					out=normalise(tmp,norm,mon_int_range[0],mon_int_range[1])		else:			out=normalise(tmp,norm)		tmp=integrate(out,tmin,tmax,specmin,specmax)		tmp=sumspec(tmp)		if len(args)==2:			outdat.setCell(1,jj,args[0]+args[1]*(jj-1))		else:			outdat.setCell(1,jj,jj)		outdat.setCell(2,jj,tmp.readY(0)[0])		outdat.setCell(3,jj,tmp.readE(0)[0])		print 'Integral from run ', i, '=' ,tmp.readY(0)[0],'+/-',tmp.readE(0)[0]		jj=jj+1	qti.app.plot(outdat,(1,2,3),2)	return outdatdef Log(wksp_in):	"""	log10 of input workspace	"""	n,r=lhs('both')	wksp_out=r[0]	Logarithm(InputWorkspace=wksp_in,OutputWorkspace=wksp_out,Natural="0")	return mtd[wksp_out]def Ln(wksp_in):	"""	loge of input	"""	n,r=lhs('both')	wksp_out=r[0]	Logarithm(InputWorkspace=wksp_in,OutputWorkspace=wksp_out,Natural="1")	return mtd[wksp_out]		def etrans(*args):	"""	convert units to energy transfer	no renormalisation of TOF scale	convert input to energy transfer and return	uses the ei stored in the wksp from get_ei as default if ei is specified then the vaule is FIXED to that	"""		n,r=lhs('both')	wksp_out=r[0]		if len(args)==1:		wksp_in=args[0]		ei = float(wksp_in.getSampleDetails().getLogData("Ei").value())		print 'Converting to energy transfer ei = ', ei,'meV'				ConvertUnits(InputWorkspace=wksp_in,OutputWorkspace=wksp_out,Target="DeltaE",EMode="Direct",EFixed=ei)		if len(args)==2:		wksp_in=args[0]		ei=args[1]				print 'Converting to energy transfer ei = ', ei, 'meV'				ConvertUnits(InputWorkspace=wksp_in,OutputWorkspace=wksp_out,Target="DeltaE",EMode="Direct",EFixed=ei)		return mtd[wksp_out]def sumspec(*args):	"""	#sums spectra onto a single 1d matrix		w2=sumpsec(w1) sum all spec in w1 	w2=sumpsec(w1,10,100) sum spec 10-->100 in w1	"""	n,r=lhs('both')	wksp_out=r[0]	if len(args)==1:		wksp_in=args[0]			SumSpectra(InputWorkspace=wksp_in,OutputWorkspace=wksp_out,IncludeMonitors="1")	if len(args)==3:		wksp_in=args[0]		index_1=args[1]-1 #convert to workspace index		index_2=args[2]-1		SumSpectra(InputWorkspace=wksp_in,OutputWorkspace=wksp_out,StartWorkspaceIndex=index_1,EndWorkspaceIndex=index_2,IncludeMonitors="1")	return mtd[wksp_out]def integrate(*args):	"""	#integrates spectra range within limits of x scale 2d		w1=integrate(w2) integrate all w2	w1=integrate(w2,10,1000) integrate w2 within limits of 10 and 1000	"""	n,r=lhs('both')	if len(r)==0:		wksp_out='tmp_integral'	if len(r)==1:		wksp_out=r[0]		#get around bin width issue	wksp_in=args[0]			if len(args)==1:		wksp_in=args[0]			Integration(InputWorkspace=wksp_in,OutputWorkspace=wksp_out,IncludePartialBins="1")	if len(args)==3:		wksp_in=args[0]		xrange_lo=args[1]		xrange_hi=args[2]		Integration(InputWorkspace=wksp_in,OutputWorkspace=wksp_out,RangeLower=xrange_lo,RangeUpper=xrange_hi,IncludePartialBins="1")	if len(args)==5:		wksp_in=args[0]		xrange_lo=args[1]		xrange_hi=args[2]		specrange_lo=args[3]-1#convert to workspace index		specrange_hi=args[4]-1		Integration(InputWorkspace=wksp_in,OutputWorkspace=wksp_out,RangeLower=xrange_lo,RangeUpper=xrange_hi,StartWorkspaceIndex=specrange_lo,EndWorkspaceIndex=specrange_hi,IncludePartialBins="1")	if wksp_out =='tmp_integral':		print 'Integral = ' ,mtd[wksp_out].readY(0)[0],'+/-',mtd[wksp_out].readE(0)[0]			return mtd[wksp_out]def transpose(wksp_in):	"""	transpose workspace	"""	n,r=lhs('both')	wksp_out=r[0]	Transpose(InputWorkspace=wksp_in,OutputWorkspace=wksp_out)	return mtd[wksp_out]def pwksp(wksp,spec):	"""	Plot spectrum from workpsace	pwksp(w1,10), plot spec 10 from w1	pwksp(w1,[10,1,100]) plot 10 to 100 from w1	"""  	if is_int(spec):		spec=spec-1					if is_list(spec):		spec2matrixsub(spec)	plotSpectrum(wksp,spec,True)def changecolour(*args):	returndef changemarker(*args):	returndef is_int(inp):	#logical type check for integer	try:		return int(inp)==inp	except:		return Falsedef is_list(inp):	#logical type check for list	try:		return list(inp)==inp	except:		return False		def spec2matrixsub(inp):	#convert spectrum number to matric subscipt i.e. -1	if is_list(inp):		tmp=inp		for i in range(len(tmp)):			tmp[i]=tmp[i]-1		return tmp	def display(spec):	"""	diaplays spectrum from currently assigned workspace or file	"""#assume the default workspace is current_working_data		if is_int(spec):		spec=spec-1					if is_list(spec):		spec2matrixsub(spec)	plotSpectrum(current_working_data,spec)	def displayerror(spec):	"""	diaplays spectrum with erros from currently assigned workspace or file	"""#assume the default workspace is current_working_data	if is_int(spec):		spec=spec-1					if is_list(spec):		spec2matrixsub(spec)	plotSpectrum(current_working_data,spec,True)	                def getspec(wksp_in,spec):	"""	extract specrtum as new workspace	w2=getspec(w1,10) get spec 10 as w2	"""	n,r=lhs('both')	wksp_out=r[0]		spec=spec-1	X=list(wksp_in.readX(spec))	Y=list(wksp_in.readY(spec))	E=list(wksp_in.readE(spec))	CreateWorkspace(wksp_out, X, Y, E)	return mtd[wksp_out]def smooth(wksp_in,fac):	"""	adjacent average smooth of 2d data	"""	wksp_out=wksp_in	SmoothData(wksp_in,wksp_out,NPoints=str(fac))def pcolor(*args):	"""	2d plot using the mantid plot plotting rather that matplotlib	"""       	wksp_in=args[0]		dat=importMatrixWorkspace(str(wksp_in))	g2d=dat.plotGraph2D()		#set z scale 	if len(args)==2:		ll=g2d.activeLayer()		ll.setAxisScale(Layer.Right,0,args[1])	if len(args)==3:		ll=g2d.activeLayer()		ll.setAxisScale(Layer.Right,args[1],args[2])def psurf(*args):	#3d plot of the matrix workspace	wksp_in=args[0]		dat=importMatrixWorkspace(str(wksp_in))	g2d=dat.plotGraph3D()def help(*args):	if len(args)==0:		print 'Mantid Built in Fucntions'		mantidHelp()		print '--------------------------------------------------------------------'		print '--------------------------------------------------------------------'		print 'qtiGenie functions'		print '--------------------------------------------------------------------'		print '\t''trim(dat,t1,t2) '		print '\t''listfiles() '		print '\t''setinst() '		print '\t''head(runnumber) '		print '\t''iv(wksp_in) '		print '\t''load(*args) '		print '\t''load_monitors(*args) '		print '\t''getnumor(runnumber) '		print '\t''loadascii(name) '		print '\t''ass(wksp) '			print '\t''clear(wksp) '			print '\t''whos() '		print '\t''default_plotting(inp) '		print '\t''dspacing(wksp_in) '		print '\t''get_ei(wksp_in,guess) '		print '\t''normalise(*args) '		print '\t''rebin(wksp_in,params) '		print '\t''integrate_over_runs(runstart,runstop,tmin,tmax,specmin,specmax) '			print '\t''Log(wksp_in) '			print '\t''Ln(wksp_in) '		print '\t''etrans(*args) '		print '\t''sumspec(*args) '		print '\t''integrate(*args) '		print '\t''transpose(wksp_in) '		print '\t''pwksp(wksp,spec) '		print '\t''changecolour(*args) '		print '\t''changemarker(*args) '		print '\t''p(spec) '		print '\t''pe(spec) '		print '\t''getspec(spec) '		print '\t''get2d() '		print '\t''p2d(*args) '		print '\t''psurf(*args) '		print '\t''plus(a,b) '		print '\t''minus(a,b) '		print '\t''mult(a,b) '		print '\t''div(a,b) '         		print '\t''help() '		print '--------------------------------------------------------------------'			print 'qtiGenie classes'		print '--------------------------------------------------------------------'		print 'class Data_1D() '		print '--------------------------------------------------------------------'		print '\t''__init__(Data_1D) '  		print '\t''plot(wksp) '		print '\t''plotwe(wksp) '		print '\t''Add_1d(wksp,factor) '		print '\t''Minus_1D(wksp,factor) '		print '\t''Multiply_1d(wksp,factor) '		print '\t''Divide_1d(wksp,factor) '		print '\t''integrate(wksp,t1,t2) '		print '\t''xscale(dat,t1,t2) '		print '--------------------------------------------------------------------'			print 'class Data_2D()'		print '--------------------------------------------------------------------'		print '\t''__init__(Data_2D) '		print '\t''sumspec(wksp,*args) '		print '\t''sum2d(wsk,s1,s2) '	else:		execstr='print '+str(args[0])+'.__doc__'		exec(execstr)#alias names for this moduled=displayde=displayerrorp=pcolor